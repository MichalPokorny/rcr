#!/usr/bin/ruby -w

require 'rcr/config'
require 'rcr/letter-classifier/neural'
require 'rcr/data/image'
require 'rcr/easy'

require 'rubyfish'

5.times do
	classifier = RCR.build_letter_classifier
	segmentator = RCR.build_word_segmentator

	bootstrap_dataset = {}
	('A'..'Z').each do |l| bootstrap_dataset[l] = [] end

	diff_sum = 0

	Dir[File.join(RCR::Config.segmentation_inputs_path, "*")].each do |input_dir|
		# FUJ
		raise unless input_dir =~ /\/(\d+)(\/|\Z)/
		# if $1.to_i < 5 || $1.to_i > 15
			# puts "skip #$1"
		#	next
		# end

		next if $1 == "4" || $1 == "6" || $1 == "11"
		# /FUJ
		puts "running #$1"

		image = RCR::Data::Image.load(File.join(input_dir, "data.png"))
		segmentation = segmentator.segment(image)

		expect = File.read(File.join(input_dir, "expect.txt")).strip

		text = segmentation.detected_text(classifier)
		distance = RubyFish::Levenshtein.distance(text, expect)
		puts "Segmentation says: #{text}, expected: #{expect}. LSD = #{distance}"
		diff_sum += distance
		word_segmentation = segmentator.segment_for_word(image, expect)

		#filename = "segmented.png"
		segmentator.show_oversegmentation(image) # Must be here.

		if word_segmentation
			with_best_found = image.dup
			word_segmentation.draw_on_image!(with_best_found)
			with_best_found.save("segmented_#{expect}.png")

			word_segmentation.boxes.each.with_index do |box, j|
				crop = box.to_image
				# TODO FUJ
				letter = expect[j]
				input = RCR::LetterClassifier::Neural.image_to_net_input(crop)

				bootstrap_dataset[letter] << input
			end
		else
			puts "Best segmentation for #{expect} not found."
		end

		#segmentation.draw_on_image!(image)
		#image.save(filename)

		#puts "Segmented image saved in #{filename}"
	end

	classifier.train(bootstrap_dataset)
	classifier.save(File.join(RCR::Config.trained_path, "letter-classifier"))

	puts "Training finished."
	puts "Total distance before: #{diff_sum}"
end
