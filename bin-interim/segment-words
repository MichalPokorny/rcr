#!/usr/bin/ruby -w

require 'rcr/config'
require 'rcr/letter_classifier'
require 'rcr/letter_classifier/neural'
require 'rcr/data/image'
require 'rcr/easy'
require 'rcr/letter_classifier/input_transformer/combine'
require 'rcr/feature_extractor/raw_image'
require 'rcr/feature_extractor/content_aspect_ratio'
require 'rcr/data/dataset'
require 'rcr/heuristic_oversegmenter/local_minima'
require 'rcr/word_segmentator/heuristic_oversegmentation'

require 'rubyfish'

require 'fileutils'
Dir["segmented_*.png"].each { |f| FileUtils.rm(f) }

OUTPUT_DIR = "output-segmented-words"
FileUtils.mkdir_p(OUTPUT_DIR)

BATCH_SIZE = 10
GENERATIONS = 30

1000.times do |generation|
	dataset = RCR::LetterClassifier.load_inputs(RCR::Config.letter_inputs_path)

	transformers = []

	# TODO: ukladat v datech "jakeho logickeho typu jsou"? Nechci prece
	# na 1D data pripadne poustet konvolucni neuronovou sit...
	transformers << RCR::LetterClassifier::InputTransformer::Basic.new(
		RCR::FeatureExtractor::RawImage.new(16, 16, guillotine: true, forget_aspect_ratio: true, normalize_contrast: true)
	)

	transformers << RCR::LetterClassifier::InputTransformer::Basic.new(
		RCR::FeatureExtractor::ContentAspectRatio.new
	)

	classifier = RCR::LetterClassifier::Neural.new(RCR::LetterClassifier::InputTransformer::Combine.new(transformers)) # RCR.build_letter_classifier

	classifier.start_anew(allowed_chars: ('A'..'Z'))

	segmentator = RCR::WordSegmentator::HeuristicOversegmentation.new(
		RCR::HeuristicOversegmenter::LocalMinima.new, classifier, RCR.build_language_model)
	# XXX: CHYBA: segmentator = RCR.build_word_segmentator

	bootstrap_dataset = RCR::Data::Dataset.new

	diff_sum = 0

	batch = Dir[File.join(RCR::Config.segmentation_inputs_path, "*")].shuffle.take(BATCH_SIZE)
	batch.each.with_index do |input_dir, i|
		raise unless input_dir =~ /\/(\d+)(\/|\Z)/

		puts "running #$1 (#{i+1}/#{batch.size})"

		image = RCR::Data::Image.load(File.join(input_dir, "data.png"))
		segmentation, score = *segmentator.segment_with_score(image)

		expect = File.read(File.join(input_dir, "expect.txt")).strip

		text = segmentation.detected_text(classifier)
		distance = RubyFish::Levenshtein.distance(text, expect)
		puts "Segmentation says: #{text}, expected: #{expect}, score: #{score}. LSD = #{distance}"
		diff_sum += distance
		word_segmentation, score = *segmentator.segment_for_word_with_score(image, expect)

		#filename = "segmented.png"
		segmentator.show_oversegmentation(image) # Must be here.

		if word_segmentation
			with_best_found = image.dup
			word_segmentation.draw_on_image!(with_best_found)
			with_best_found.save(File.join(OUTPUT_DIR, "segmented_#{expect}_gen#{generation}.png"))

			word_segmentation.boxes.each.with_index do |box, j|
				crop = box.to_image
				# TODO FUJ
				letter = expect[j]

				bootstrap_dataset.insert(crop, letter)
			end
			puts "Best segmentation for #{expect} score: #{score}"
		else
			puts "Best segmentation for #{expect} not found."
		end

		#segmentation.draw_on_image!(image)
		#image.save(filename)

		#puts "Segmented image saved in #{filename}"
	end

	puts "Total distance before: #{diff_sum}"

	classifier.train(bootstrap_dataset, generations: GENERATIONS, logging: true)
	classifier.save(File.join(RCR::Config.trained_path, "letter-classifier-oversegmentation"))
	puts "-----------"
	puts "Training finished."
end
